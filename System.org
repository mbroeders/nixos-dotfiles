#+title: System Configuration With Flakes
#+property: header-args :mkdirp yes
#+property: header-args :noweb yes :results silent
#+property: header-args:emacs-lisp :tangle .emacs.d/init.el

* Table of Contents (ToC)
:PROPERTIES:
:TOC:      :include all :force (depth) :ignore (this) :local (depth)
:END:
:CONTENTS:
- [[#system-configuration][System Configuration]]
  - [[#flakenix][flake.nix]]
    - [[#stable-packages][stable packages]]
    - [[#nixos][nixos]]
    - [[#home-manager][home manager]]
    - [[#packages][packages]]
    - [[#overlays][overlays]]
  - [[#nixos][nixos]]
    - [[#general][general]]
    - [[#re-expose-nixpkgs][re-expose nixpkgs]]
    - [[#users][users]]
    - [[#machines][machines]]
      - [[#wheeler][wheeler]]
        - [[#general][general]]
        - [[#disks][disks]]
        - [[#clickpad][clickpad]]
        - [[#networking][networking]]
        - [[#laptop-specific][laptop-specific]]
      - [[#hopper][hopper]]
        - [[#general][general]]
        - [[#disks][disks]]
        - [[#networking][networking]]
  - [[#emacs][emacs]]
    - [[#install-emacs][install emacs]]
  - [[#environment][environment]]
    - [[#exwm][exwm]]
    - [[#todo-screen-locking][todo screen locking]]
      - [[#slock][slock]]
      - [[#xss-lock][xss-lock]]
    - [[#misc][misc]]
      - [[#keyboard][keyboard]]
  - [[#network][network]]
    - [[#networkmanager][networkmanager]]
    - [[#gnupg][gnupg]]
  - [[#sound][sound]]
  - [[#services][services]]
    - [[#syncthing][syncthing]]
    - [[#screen-brightness][screen brightness]]
  - [[#browsers][browsers]]
  - [[#todo-mail-setup][todo mail setup]]
  - [[#applications][applications]]
    - [[#automount-with-udiskie][automount with udiskie]]
    - [[#zathura][zathura]]
    - [[#mpv][mpv]]
    - [[#vim-backup-editor][vim (backup editor)]]
    - [[#terminal][terminal]]
      - [[#shell-zsh][shell (zsh)]]
    - [[#git][git]]
    - [[#todo-desktop-various-needs-sorting][todo desktop various (needs sorting)]]
- [[#emacs-configuration][Emacs Configuration]]
  - [[#startup-performance][Startup Performance]]
  - [[#prerequisites-and-machine-specifics][Prerequisites and Machine Specifics]]
  - [[#package-management][Package Management]]
  - [[#native-compilation][Native Compilation]]
  - [[#keeping-your-system-clean][Keeping Your System Clean]]
  - [[#update-load-path][Update Load Path]]
  - [[#server-mode][Server-mode]]
  - [[#desktop][Desktop]]
  - [[#ui][UI]]
    - [[#basic][Basic]]
    - [[#themes][Themes]]
    - [[#font][Font]]
    - [[#modeline][Modeline]]
    - [[#auto-reverting-changed-files][Auto-Reverting Changed Files]]
    - [[#rainbow-coloured-parentheses][Rainbow Coloured Parentheses]]
    - [[#highlight-matching-braces][Highlight Matching Braces]]
    - [[#set-default-browser-in-emacs][Set default browser in Emacs]]
    - [[#pinentry][Pinentry]]
  - [[#window-management][Window Management]]
    - [[#frame-scaling--zooming][Frame Scaling / Zooming]]
  - [[#evil-centered-keyboard-configuration][Evil Centered Keyboard Configuration]]
    - [[#general][General]]
    - [[#evil][Evil]]
    - [[#which-key][Which-key]]
    - [[#extra-keybindings][Extra keybindings]]
  - [[#editing-configuration][Editing Configuration]]
    - [[#tab-widths-and-spaces-for-indentation][Tab Widths and Spaces For Indentation]]
    - [[#commenting-lines][Commenting Lines]]
    - [[#automatically-clean-whitespace][Automatically clean whitespace]]
  - [[#file-management][File-Management]]
    - [[#dired][Dired]]
      - [[#key-bindings][Key Bindings]]
        - [[#navigation][Navigation]]
        - [[#marking-files][Marking files]]
        - [[#copying-and-renaming-files][Copying and Renaming files]]
        - [[#deleting-files][Deleting files]]
        - [[#creating-and-extracting-archives][Creating and extracting archives]]
        - [[#other-common-operations][Other common operations]]
      - [[#configuration][Configuration]]
  - [[#development][Development]]
    - [[#productivity][Productivity]]
      - [[#syntax-checking-with-flycheck][Syntax checking with Flycheck]]
      - [[#snippets][Snippets]]
    - [[#projectile][Projectile]]
    - [[#magit][Magit]]
    - [[#languages][Languages]]
      - [[#ide-features-with-lsp-mode][IDE Features with lsp-mode]]
        - [[#lsp-mode][lsp-mode]]
        - [[#lsp-ui][lsp-ui]]
        - [[#lsp-treemacs][lsp-treemacs]]
      - [[#better-completions-with-company-mode][Better Completions with Company Mode]]
      - [[#debugging-with-dap-mode][Debugging with dap-mode]]
      - [[#eglot-as-language-server][Eglot as language server]]
      - [[#markdown][Markdown]]
      - [[#nix][Nix]]
      - [[#python][Python]]
      - [[#rust][Rust]]
      - [[#scheme][Scheme]]
  - [[#completion-framework][Completion Framework]]
    - [[#vertico][Vertico]]
    - [[#marginalia][Marginalia]]
    - [[#consult][Consult]]
  - [[#org-mode][Org Mode]]
    - [[#org-ui][Org UI]]
    - [[#configuration][Configuration]]
    - [[#note-testing-new-workflow][NOTE TESTING NEW WORKFLOW]]
      - [[#file-paths][File paths]]
      - [[#workflow-states][Workflow states]]
      - [[#tags][Tags]]
      - [[#agenda][Agenda]]
      - [[#capture-templates][Capture templates]]
      - [[#new-workflow][New Workflow]]
    - [[#modules][Modules]]
    - [[#babel][Babel]]
    - [[#block-templates][Block Templates]]
    - [[#org-bullets-using-superstar][Org Bullets using Superstar]]
    - [[#archiving-made-easier---function][Archiving Made Easier - Function]]
    - [[#update-table-of-contents-on-save][Update Table of Contents on Save]]
    - [[#end-of-use-package-org][End of use-package org]]
  - [[#org-journal][Org Journal]]
  - [[#sync-google-calendar][Sync Google Calendar]]
  - [[#presentations-with-org-re-reveal][Presentations with org-re-reveal]]
  - [[#useful-packages-and-apps][Useful Packages and Apps]]
    - [[#app-launcher][App Launcher]]
    - [[#deft-note-taking][Deft (note taking)]]
    - [[#erc-chat][ERC (chat)]]
      - [[#connect-automatically-with-c-c-c][Connect automatically with C-c c]]
      - [[#basic-configuration][Basic Configuration]]
      - [[#jumping-irc-buffers-easily][Jumping IRC Buffers Easily]]
      - [[#colorize-nicks][Colorize Nicks]]
      - [[#display-inline-images][Display Inline Images]]
    - [[#expand-region][Expand Region]]
    - [[#helpful][Helpful]]
    - [[#mail][Mail]]
    - [[#notifications][Notifications]]
    - [[#text-scaling-using-hydra][Text Scaling using Hydra]]
  - [[#terminals][Terminals]]
    - [[#eshell][Eshell]]
      - [[#configuration][Configuration]]
      - [[#toggling-eshell][Toggling Eshell]]
    - [[#vterm][Vterm]]
  - [[#password-management][Password Management]]
  - [[#system-utilities][System Utilities]]
    - [[#daemons][Daemons]]
    - [[#proced][Proced]]
  - [[#runtime-performance][Runtime Performance]]
  - [[#inspiration][Inspiration]]
- [[#dotfile-helper-scripts][Dotfile Helper Scripts]]
:END:

* System Configuration

** flake.nix

the following goes into flake.nix

#+begin_src nix :tangle ./flake.nix :noweb no-export :padline no
  #
  # this file is auto-generated from "system.org"
  #
  {
    description = "my packages and nixos/home-manager configurations";

    inputs = {
      nixpkgs = {
        type = "github";
        owner = "nixos";
        repo = "nixpkgs";
        ref = "nixpkgs-unstable";
      };

      <<flake-inputs>>
    };

    outputs = { self, ... }@inputs:
      let
        # flakes are evaluated hermetically, thus are unable to access
        # host environment (including looking up current system).
        #
        # that's why flakes must explicitly export sets for each system
        # supported.
        systems = ["x86_64-linux"];

        # genAttrs applies f to all elements of a list of strings, and
        # returns an attrset { name -> result }
        #
        # useful for generating sets for all systems or hosts.
        genAttrs = list: f: inputs.nixpkgs.lib.genAttrs list f;

        # generate pkgs set for each system. this takes into account my
        # nixpkgs config (allowUnfree) and my overlays.
        pkgsBySystem =
          let mkPkgs = system: import inputs.nixpkgs {
                inherit system;
                overlays = self.overlays.${system};
                config = { allowUnfree = true; };
              };
          in genAttrs systems mkPkgs;

        # genHosts takes an attrset { name -> options } and calls mkHost
        # with options+name. the result is accumulated into an attrset
        # { name -> result }.
        #
        # used in nixos and home manager configurations.
        genHosts = hosts: mkHost:
          genAttrs (builtins.attrNames hosts) (name: mkHost ({ inherit name; } // hosts.${name}));

        # merges a list of attrsets into a single attrset
        mergeSections = inputs.nixpkgs.lib.foldr inputs.nixpkgs.lib.mergeAttrs {};

      in mergeSections [
        <<flake-outputs-nixos>>
        <<flake-outputs-home-manager>>
        <<flake-outputs-packages>>
        <<flake-outputs-overlays>>
      ];
  }

#+end_src

=Nix flakes= are still an experimental feature, so you need the following in nixos configuration to enable it.

#+begin_src nix :noweb-ref nixos-section
  {
    nix = {
      package = pkgs.nixFlakes;
      extraOptions = ''
        experimental-features = nix-command flakes ca-references
      '';
    };
  }
#+end_src

*** stable packages

For packages that are broken in nixpkgs-unstable, expose the latest stable channel as ~pkgs.stable~.
So first, let's add this to the input and flake-overlays.

#+begin_src nix :noweb-ref flake-inputs
  nixpkgs-stable = {
    type = "github";
    owner = "nixos";
    repo = "nixpkgs";
    ref = "nixos-21.05";
  };
#+end_src

#+begin_src nix :noweb-ref flake-overlays
  (final: prev: {
    stable = import inputs.nixpkgs-stable {
      inherit system;
      overlays = self.overlays.${system};
      config = { allowUnfree = true; };
    };
  })
#+end_src

*** nixos

Here, we expose our =Nixos= configurations. =Wheeler= is my main laptop, =Hopper= my desktop machine.

#+begin_src nix :noweb-ref flake-outputs-nixos
  (let
    nixosHosts = {
      wheeler = { system = "x86_64-linux";  config = ./nixos-config.nix; };

      # i'll use the same configuration file for hopper, because the configuration
      # details are mostly the same. let's see if this works.
      hopper = { system = "x86_64-linux";  config = ./nixos-config.nix; };
    };

    mkNixosConfiguration = { name, system, config }:
      let pkgs = pkgsBySystem.${system};
      in inputs.nixpkgs.lib.nixosSystem {
        inherit system;
        modules = [
          { nixpkgs = { inherit pkgs; }; }
          (import config)
        ];
        specialArgs = { inherit name inputs; };
      };

  in {
    nixosConfigurations = genHosts nixosHosts mkNixosConfiguration;
  })
#+end_src

*** home manager

Add =home-manager= to flake inputs...

#+begin_src nix :noweb-ref flake-inputs
  home-manager = {
    type = "github";
    owner = "rycee";
    repo = "home-manager";
    ref = "master";
    inputs.nixpkgs.follows = "nixpkgs";
  };
#+end_src

... and expose =home-manager= configurations.

#+begin_src nix :noweb-ref flake-outputs-home-manager
  (let
    homeManagerHosts = {
      markBroeders = {
        system = "x86_64-linux";
        config = ./home.nix;
        username = "mark";
        homeDirectory = "/home/mark";
      };
    };

    mkHomeManagerConfiguration = { system, name, config, username, homeDirectory }:
      let pkgs = pkgsBySystem.${system};
      in inputs.home-manager.lib.homeManagerConfiguration {
        inherit system pkgs username homeDirectory;
        configuration = { ... }: {
          nixpkgs.config.allowUnfree = true;
          nixpkgs.config.firefox.enableTridactylNative = true;
          nixpkgs.overlays = self.overlays.${system};
          imports = [
            self.lib.home-manager-common

            (import config)
          ];
        };
      };

  in {
    # re-export common home-manager configuration to be reused between
    # nixos module and standalone home-manager config.
    lib.home-manager-common = { lib, pkgs, config, ... }: {
      imports = [
        <<home-manager-section>>
      ];
      # home.stateVersion = "20.09";
      home.stateVersion = "21.03";
    };
    homeManagerConfigurations = genHosts homeManagerHosts mkHomeManagerConfiguration;
  })
#+end_src

Finally, integrate the =home-manager= module into nixos.

#+begin_src nix :noweb-ref nixos-section
  {
    imports = [inputs.home-manager.nixosModules.home-manager];
    home-manager = {
      useUserPackages = true;
      useGlobalPkgs = true;
      users.mark = inputs.self.lib.home-manager-common;
    };
  }
#+end_src

*** packages

Generate packages set for each supported system.

#+begin_src nix :noweb-ref flake-outputs-packages
  (let
    mkPackages = system:
      let
        pkgs = pkgsBySystem.${system};
      in
        mergeSections [
          <<flake-packages>>
        ];

  in {
    packages = genAttrs systems mkPackages;
  })
#+end_src

*** overlays

And generate overlays for all supported systems.

#+begin_src nix :noweb-ref flake-outputs-overlays
  (let
    mkOverlays = system: [
      # mix-in all local packages, so they are available as pkgs.${packages-name}
      (final: prev: self.packages.${system})

      <<flake-overlays>>
    ];
  in {
    overlays = genAttrs systems mkOverlays;
  })
#+end_src

** nixos
*** general

I'm a [[http://nixos.org/][nixos]] user. what's cool about it is that i can describe all my system configuration in one file (almost). i can execute a single command and have a system with the same software, system settings, etc.

An outline of configuration looks like this:

#+begin_src nix :tangle ./nixos-config.nix :noweb no-export :padline no
  #
  # this file is auto-generated from "system.org"
  #
  { name, config, pkgs, lib, inputs, ... }:
  let
    machine-config = lib.getAttr name {
      wheeler = [
        <<machine-wheeler>>
      ];
      hopper = [
        <<machine-hopper>>
      ];
    };

  in
  {
    imports = [
      {
        nixpkgs.config.allowUnfree = true;

        # the nixos release to be compatible with for stateful data such as databases.
        system.stateVersion = "21.05";
      }

      <<nixos-section>>
    ] ++ machine-config;
  }
#+end_src

this =<<nixos-section>>= is replaced by other parts of this doc.

*** re-expose nixpkgs

#+begin_src nix :noweb-ref nixos-section
  {
    # for compatibility with nix-shell, nix-build, etc.
    environment.etc.nixpkgs.source = inputs.nixpkgs;
    nix.nixPath = ["nixpkgs=/etc/nixpkgs"];

    # register self and nixpkgs as flakes for quick access
    nix.registry = {
      self.flake = inputs.self;

      nixpkgs.flake = inputs.nixpkgs;
    };
  }
#+end_src

Same, but for home manager–managed host.

#+begin_src nix :noweb-ref home-manager-section
  {
    home.file."nixpkgs".source = inputs.nixpkgs;
    systemd.user.sessionVariables.NIX_PATH = lib.mkForce "nixpkgs=$home/nixpkgs\${NIX_PATH:+:}$NIX_PATH";

    xdg.configFile."nix/registry.json".text = builtins.toJSON {
      version = 2;
      flakes = [
        {
          from = { id = "self"; type = "indirect"; };
          to = ({
            type = "path";
            path = inputs.self.outPath;
          } // lib.filterAttrs
            (n: v: n == "lastModified" || n == "rev" || n == "revCount" || n == "narHash")
            inputs.self);
        }
        {
          from = { id = "nixpkgs"; type = "indirect"; };
          to = ({
            type = "path";
            path = inputs.nixpkgs.outPath;
          } // lib.filterAttrs
            (n: v: n == "lastModified" || n == "rev" || n == "revCount" || n == "narHash")
            inputs.nixpkgs);
        }
      ];
    };
  }
#+end_src

*** users

I'm the only user of the system:

#+begin_src nix :noweb-ref nixos-section
  {
    users.extraUsers.mark = {
      isNormalUser = true;
      # uid = 1000;
      shell = pkgs.zsh;
      extraGroups = [ "wheel" "audio" "video" "input" "sound" "networkmanager" "power" ]; # enable ‘sudo’ for the user.
    };
    nix.trustedUsers = ["mark"];
  }
#+end_src

=initialpassword= is used only first time when user is created. it must be changed as soon as possible with =passwd=.

*** machines
**** wheeler
***** general

This is my asus zenbook.

#+begin_src nix :noweb-ref machine-wheeler
  {
    imports = [
      inputs.nixpkgs.nixosModules.notDetected
    ];

    boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "nvme" "usb_storage" "sd_mod" ];
    boot.initrd.kernelModules = [ ];
    boot.kernelModules = [ "kvm-intel" ];
    boot.extraModulePackages = [ ];
    # enable ntfs support
    boot.supportedFilesystems = [ "ntfs" ];

    powerManagement.cpuFreqGovernor = lib.mkDefault "powersave";

    # use the systemd-boot efi boot loader.
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    boot.loader.grub.useOSProber = true;
  }
#+end_src

***** disks

Setup disks

#+begin_src nix :noweb-ref machine-wheeler
  {
    fileSystems."/" =
    { device = "/dev/disk/by-uuid/d1f8c7ae-ecd8-4fc1-937c-838360d8ad28";
      fsType = "ext4";
    };

  boot.initrd.luks.devices."cryptroot".device = "/dev/disk/by-uuid/79763e12-47f4-48a5-8957-a6947fa81a9d";

  fileSystems."/boot" =
    { device = "/dev/disk/by-uuid/0037-9737";
      fsType = "vfat";
    };

  swapDevices =
    [ { device = "/dev/disk/by-uuid/c264e2d9-0eed-4fd3-b19e-8b9574459d7e"; }
    ];

    # mount ntfs-filesystem as read/write
    # fileSystems."/path/to/mount/to" =
    #  { device = "/path/to/the/device";
    #    fsType = "ntfs";
    #    options = [ "rw" "uid=theuidofyouruser"];
    #  };
  }
#+end_src

***** clickpad

#+begin_src nix :noweb-ref machine-wheeler
  {
    # enable touchpad support (enabled default in most desktopmanager).
    services.xserver.libinput = {
      enable = true;
      touchpad.tapping = true;
      touchpad.clickMethod = "clickfinger";
      touchpad.naturalScrolling = true;
    };
  }
#+end_src

***** networking

#+begin_src nix :noweb-ref machine-wheeler
  {
    networking.hostName = "wheeler";

    # the global useDHCP flag is deprecated, therefore explicitly set to false here.
    # per-interface useDHCP will be mandatory in the future, so this generated config
    # replicates the default behaviour.
    networking.useDHCP = false;
    networking.interfaces.wlo1.useDHCP = true;
  }
#+end_src

***** laptop-specific

some laptop specific programs and tools, such as bluetooth,
power management, and networkmanager-applet

#+begin_src nix :noweb-ref machine-wheeler
  # enable tlp package for power management
  {
    services.tlp.enable = true;

    # enable bluetooth
    hardware.bluetooth.enable = true;
    services.blueman.enable = true;

    programs.nm-applet.enable = true;
  }
#+end_src

**** hopper
***** general

This is my amd ryzen 3600 powered desktop.

#+begin_src nix :noweb-ref machine-hopper
  {
    imports = [
      inputs.nixpkgs.nixosModules.notDetected
    ];

    boot.initrd.availableKernelModules = [ "xhci_pci" "ahci" "usb_storage" "usbhid" "sd_mod" ];
    boot.initrd.kernelModules = [ ];
    boot.kernelModules = [ "kvm-amd" ];
    boot.extraModulePackages = [ ];
    # enable ntfs support
    boot.supportedFilesystems = [ "ntfs" ];

    # use the systemd-boot efi boot loader.
    boot.loader.systemd-boot.enable = true;
    boot.loader.efi.canTouchEfiVariables = true;
    boot.loader.grub.useOSProber = true;
  }
#+end_src

***** disks
setup disks

#+begin_src nix :noweb-ref machine-hopper
  {
    fileSystems."/" =
      { device = "/dev/disk/by-uuid/cb10508b-e6dc-43fd-baf6-38f66851d6a3";
        fsType = "ext4";
      };

    fileSystems."/boot" =
      { device = "/dev/disk/by-uuid/9E07-E045";
        fsType = "vfat";
      };

    fileSystems."/home" =
      { device = "/dev/disk/by-uuid/38fb5ec3-1215-4c9f-bc54-7c206f5176ec";
        fsType = "ext4";
      };

    swapDevices =
      [ { device = "/dev/disk/by-uuid/273ba5a6-2ca3-4cb9-be62-94bc16fce9cd"; }
      ];

    # mount ntfs-filesystem as read/write
    #fileSystems."/path/to/mount/to" =
    #  { device = "/path/to/the/device";
    #    fsType = "ntfs";
    #    options = [ "rw" "uid=theuidofyouruser"];
    #  };
  }
#+end_src

***** networking

#+begin_src nix :noweb-ref machine-hopper
  {
    networking.hostName = "hopper";

    # the global useDHCP flag is deprecated, therefore explicitly set to false here.
    # per-interface useDHCP will be mandatory in the future, so this generated config
    # replicates the default behaviour.
    networking.useDHCP = false;
    networking.interfaces.enp4s0.useDHCP = true;

    # enable the openssh daemon.
    services.openssh.enable = true;
  }
#+end_src

** emacs
*** install emacs

I use emacs-28 with native compilation from [[https://github.com/nix-community/emacs-overlay][emacs-overlay]].

#+begin_src nix :noweb-ref flake-inputs
  emacs-overlay = {
    type = "github";
    owner = "nix-community";
    repo = "emacs-overlay";
  };
#+end_src

use overlay (~<<flake-overlays>>~).
unfortenately, emacsgcc (native-comp) is giving me issues with exwm, which makes it unusable at the moment. hopefully, this will change in the near future.
*note* found a possible solution, see [[https://github.com/nix-community/emacs-overlay/issues/146#issuecomment-833916006][#146]]
*note* should be fixed

#+begin_src nix :noweb-ref flake-overlays
  inputs.emacs-overlay.overlay
#+end_src

expose emacs with my packages as a top-level package (~<<flake-packages>>~).
#+begin_src nix :noweb-ref flake-packages
  (let
    emacs-base = pkgs.emacsGcc;
    emacs-packages = (epkgs:
      (with epkgs.melpaPackages; [
        <<emacs-melpa>>]) ++ (with epkgs.elpaPackages; [
          <<emacs-elpa>>]) ++ (with epkgs.orgPackages; [
            <<emacs-org>>
            org-plus-contrib]) ++ [
                pkgs.notmuch   # from main packages set
              ]
    );
    emacs-final = (pkgs.emacsPackagesGen emacs-base).emacsWithPackages emacs-packages;

  in {
    my-emacs = emacs-final // {
      base = emacs-base;
      packages = emacs-packages;
    };
  })
#+end_src

#+begin_src nix :noweb-ref nixos-section
  
  ( 
    with pkgs;
    let
      my-python-packages = python-packages: with python-packages; [
        requests
      ];
      python-with-my-packages = python3.withPackages my-python-packages;
    in
      {
        environment.systemPackages = [
          python-with-my-packages
        ];
      }
  )

#+end_src


install emacs with home manager (~<<home-manager-section>>~)

#+begin_src nix :noweb-ref home-manager-section
  {
    programs.emacs = {
      enable = true;
      package = pkgs.my-emacs.base;
      extraPackages = pkgs.my-emacs.packages;
    };
  
    # fonts and extra packages used by emacs
    home.packages = [
      pkgs.binutils       # native comp needs this
  
      # optional dependencies for emacs
      pkgs.fd
      pkgs.pinentry_emacs
      (pkgs.ripgrep.override {withPCRE2 = true;})
      pkgs.zstd                # for undo-fu-session/undo-tree compression
  
      pkgs.powerline-fonts
      pkgs.fira-code
      pkgs.fira-mono
      pkgs.cantarell-fonts
      pkgs.jetbrains-mono
      pkgs.emacs-all-the-icons-fonts
      pkgs.libertine
      pkgs.iosevka
  
      # development packages
      pkgs.cmake
      pkgs.coreutils
      pkgs.gcc
      pkgs.gnumake
      pkgs.gnutls
      pkgs.libtool
  
      pkgs.rustup
    ];
  
    # add the .emacs.d/bin folder to path // needed for doom emacs
    # home.sessionpath = [ "$home/.emacs.d/bin/" ];
  
    # for doom to properly use mu/mu4e (email) i need to make a symlink:
    # environment.etc."mu4e".source = "${pkgs.mu}/share/emacs/site-lisp/mu4e";
  }
#+end_src

emacs also needs the sqlite3 executable. i could only get this working as a system package
#+begin_src nix :noweb-ref nixos-section
  {
    environment.systemPackages = [ pkgs.sqlite ];
  }
#+end_src

** environment
*** exwm

emacs is my window manager, thanks to [[https://github.com/ch11ng/exwm][exwm]].

nixos has an exwm module, but my feeling is that it's too limiting. (~<<nixos-section>>~)
#+begin_src nix :noweb-ref nixos-section
  {
    environment.systemPackages = [
      pkgs.xorg.xhost
    ];
    services.xserver.windowManager.session = lib.singleton {
      name = "exwm";
      start = ''
        xmodmap $HOME/.dotfiles/.Xmodmap
        source $HOME/.zprofile
        xhost +si:localuser:$USER
        exec emacs --debug-init
      '';
      # exec ${pkgs.my-emacs}/bin/emacsclient -a "" -c
    };
    services.xserver.displayManager.lightdm.enable = true;
    # services.xserver.displayManager.startx.enable = true;
    services.xserver.displayManager.defaultSession = "none+exwm";
  }
#+end_src

*** todo screen locking

i use ~xss-lock~ + ~slock~ for screen locking. actual handling is coded in emacs.

**** slock

[[http://tools.suckless.org/slock/][slock]] is a simple x display locker and does not crash as xscreensaver does.

slock tries to disable oom killer (so the locker is not killed when memory is low) and this requires a suid flag for executable. otherwise, you get the following message:

#+begin_src fundamental :tangle no
  slock: unable to disable oom killer. make sure to suid or sgid slock.
#+end_src

#+begin_src nix :noweb-ref nixos-section
  {
    programs.slock.enable = true;

    services.physlock = {
      enable = true;
      lockOn.suspend = true;
      };
  }
#+end_src

**** xss-lock

[[https://bitbucket.org/raymonad/xss-lock][xss-lock]] is a small utility to plug a screen locker into screen saver extension for x. this automatically activates selected screensaver after a period of user inactivity, or when system goes to sleep.

#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [
      pkgs.xss-lock
    ];
  }
#+end_src

*** misc
i definitely use x server:
#+begin_src nix :noweb-ref nixos-section
  {
    services.xserver.enable = true;
  }
#+end_src

enable transparency

#+begin_src nix :noweb-ref home-manager-section
  {
    services.picom.enable = true; # enable compositor
  }
#+end_src

use dutch as my default locale:
#+begin_src nix :noweb-ref nixos-section
  {
    i18n.defaultLocale = "nl_NL.UTF-8";
    # i18n.supportedlocales = [ "en_US.utf-8/utf-8" ];
  }
#+end_src

setup timezone:
#+begin_src nix :noweb-ref nixos-section
  {
    time.timeZone = "Europe/Amsterdam";
  }
#+end_src

**** keyboard

configure keyboard

#+begin_src nix :noweb-ref nixos-section
  {
    # configure keymap in x11
    services.xserver.layout = "us";
    services.xserver.xkbOptions = "eurosign:e";
  
    console = {
      font = "Lat2-Terminus16";
      keyMap = "us-acentos";
    };
  }
#+end_src

i swap caps lock and right control keys using xmodmap

#+begin_src nix :noweb-ref nixos-section
  (
    let
      myXmodmap = pkgs.writeText "xkb-layout" ''
      clear lock
      clear control
      keycode 66 = control_L
      add control = control_L
      add Lock = control_R
      '';
    in
      {
        environment.systemPackages = [
          pkgs.xorg.xmodmap
        ];
  
        services.xserver.displayManager.sessionCommands = "${pkgs.xorg.xmodmap}/bin/xmodmap ${myXmodmap}";
      }
  )
  
#+end_src

don't let home manager manage keyboard (~<<home-manager-section>>~)
#+begin_src nix :noweb-ref home-manager-section
  {
    home.keyboard = null;
  }
#+end_src

** network
*** networkmanager

(~<<nixos-section>>~)

#+begin_src nix :noweb-ref nixos-section
  {
    networking = {
      networkmanager.enable = true;
    };
  }
#+end_src

install network manager applet for user. (~<<home-manager-section>>~)

#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [ pkgs.networkmanagerapplet ];
  }
#+end_src

*** gnupg

#+begin_src nix :noweb-ref nixos-section
  {
    programs.gnupg.agent = {
      enable = true;
      enableSSHSupport = true;
      pinentryFlavor = "emacs";
    };
  }
#+end_src

** sound

let's use pulseaudio for now

#+begin_src nix :noweb-ref nixos-section
  # enable sound.
  {
    sound.enable = true;
    hardware.pulseaudio.enable = true;
    hardware.pulseaudio.support32Bit = true;    ## if compatibility with 32-bit applications is desired.
  }
#+end_src

** services
*** syncthing

i use syncthing to sync my org-mode files to my phone.

#+begin_src nix :noweb-ref nixos-section
  {
    services.syncthing = {
      enable = true;
      user = "mark";
    };
  }
#+end_src

*** screen brightness

Use ~brightnessctl~ for backlight, since this works nicely with emacs

#+begin_src nix :noweb-ref nixos-section
  {
    # hardware.acpilight.enable = true;
    # environment.systemPackages = [ pkgs.acpilight ];
    environment.systemPackages = [ pkgs.brightnessctl ];
  }
#+end_src

for home manager–managed hosts.
#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [ pkgs.acpilight ];
  }
#+end_src

** browsers

qutebrowser is default

#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [
      pkgs.qutebrowser
      # pkgs.firefox
    ];
  }
#+end_src

** todo mail setup

*note* needs cleaning, this is temporary

#+begin_src nix :noweb-ref home-manager-section
  {
    # both config files get tangled from emacs.org
    programs.mbsync =
      {
        enable = true;
      };
    home.file.".mbsyncrc".source = ./.mbsyncrc;
  
    programs.msmtp =
      {
        enable = true;
      };
    home.file.".msmtprc".source = ./.msmtprc;
  }
#+end_src

**  applications
*** automount with udiskie

use =udiskie= to automount devices

#+begin_src nix :noweb-ref home-manager-section
  {
    services.udiskie = {
      enable = true;
      automount = true;
      notify = true;
      tray = "auto";
    };
  }
#+end_src

*** zathura

~<<home-manager-section>>~

#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [ pkgs.zathura ];
  }
#+end_src

*** mpv

~<<home-manager-section>>~

#+begin_src nix :noweb-ref home-manager-section
  {
    programs.mpv = {
      enable = true;
      package = pkgs.wrapMpv (pkgs.mpv-unwrapped.override { vapoursynthSupport = true; }) { youtubeSupport = true; };
      config = {
        vo = "gpu";
        hwdec = "vaapi";
        profile = "gpu-hq";
        scale = "ewa_lanczossharp";
        cscale = "ewa_lanczossharp";
        ytdl-format = "bestvideo+bestaudio";
      };
    };
  }
#+end_src

*** vim (backup editor)
*** terminal
**** shell (zsh)

~<<home-manager-section>>~

#+begin_src nix :noweb-ref home-manager-section
  {
    programs.zsh =
      {
        enable = true;
        enableAutosuggestions = true;
        enableCompletion = true;
        shellAliases =
          {
            ll="ls -all";
          };
        oh-my-zsh =
          {
            enable = true;
            plugins = [
              "git"
              "history"
              "sudo"
            ];
            theme = "agnoster";
          };
      };
  }
#+end_src

*** git

~<<home-manager-section>>~

#+begin_src nix :noweb-ref home-manager-section
  {
    programs.git =
      {
        enable = true;
        userName = "Mark Broeders";
        userEmail = "mail@markBroeders.nl";
        aliases = {
          c = "commit";
          s = "status";
          b = "branch";
          p = "pull";
          pu = "push";
        };
      };
  }
#+end_src

*** todo desktop various (needs sorting)

~<<home-manager-section>>~

#+begin_src nix :noweb-ref home-manager-section
  {
    home.packages = [
      pkgs.dunst             # keep me posted!
      pkgs.polybar           # what to do without a panel
      pkgs.feh               # background
      pkgs.udiskie

      # media
      pkgs.playerctl         # mainly for polybar script

      # work
      pkgs.mu                # mail
      pkgs.remmina           # rdp

      # other
      pkgs.pass              # password manager

      pkgs.vim
      pkgs.git
      pkgs.stow
    ];

    # texlive
    programs.texlive = {
      enable = true;
      extraPackages = tpkgs: {
        inherit (tpkgs)
          scheme-medium
          capt-of
          wrapfig;
      };
    };
  }
#+end_src

* Emacs Configuration

This is my personal Emacs configuration, mostly based upon the [[https://github.com/daviwil/emacs-from-scratch][emacs-from-scratch]] video series made by [[https://github.com/daviwil][David Wilson]]. Of course, his is not the only configuration that I checked out, there are so many great configurations to discover on the net. I try to give credit where credit is due, but I might have forgotten some.

** Startup Performance

Make startup faster by reducing the frequency of garbage collection and then use a hook to measure Emacs startup time.

#+begin_src emacs-lisp
  
  ;; The default is 800 kilobytes.  Measured in bytes.
  (setq gc-cons-threshold (* 50 1000 1000))
  
  ;; Profile emacs startup
  (add-hook 'emacs-startup-hook
            (lambda ()
              (message "*** Emacs loaded in %s with %d garbage collections."
                       (format "%.2f seconds"
                               (float-time
                                (time-subtract after-init-time before-init-time)))
                       gcs-done)))
  
#+end_src

** TODO Prerequisites and Machine Specifics

Check if I'm using GuixSD (requires =emacs-f= from =AUR= on ~Arch Linux~ or =app-emacs/f= for ~gentoo~).

#+begin_src emacs-lisp
  (setq mb/is-guix-system (and (eq system-type 'gnu/linux)
                               (require 'f)
                               (string-equal (f-read "/etc/issue")
                                             "\nThis is the GNU system.  Welcome.\n")))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  f
#+end_src

** Package Management

There are various tools you could use for managing which packages are installed and how these are configured. Emacs by definition comes with a [[https://www.emacswiki.org/emacs/InstallingPackages][simple package manager]]. One of the most used alternatives is [[https://github.com/jwiegley/use-package][use-package]], which is a macro that makes it easier to configure your packages. I choose to use [[https://github.com/jwiegley/use-package][straight.el]] for package management. So far I've noticed, it's easy to setup, allows for extensive yet easy customization and works great.

#+begin_src emacs-lisp
  
  (defvar native-comp-deferred-compilation-deny-list ())
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
  
  ;; Use straight.el for use-package expressions
  (straight-use-package 'use-package)
  
  ;; Always use straight to install on systems other than Guix
  ;;(setq straight-use-package-by-default (not (eq mb/is-guix-system 't)))
  
  ;; Always use straight to install on systems other than Linux
  (setq straight-use-package-by-default (not (eq system-type 'gnu/linux)))
  ;; Load the helper package for commands like `straight-x-clean-unused-repos'
  (require 'straight-x)
  
#+end_src

*nix packages*

#+begin_src nix :noweb-ref emacs-melpa
  use-package
#+end_src

** Native Compilation

Trying out emacs native compilation.

#+begin_src emacs-lisp
  
  (setq native-comp-async-report-warnings-errors nil)
  
#+end_src

** Keeping Your System Clean

Emacs has a tendency to create a lot of backup files which can /pollute/ your folders. There are some things you can do about this. One of the things I use, is a package called [[https://github.com/emacscollective/no-littering][no-littering]].

#+begin_src emacs-lisp
  
  ;; NOTE: If you want to move everything out of the ~/.emacs.d folder
  ;; reliably, set `user-emacs-directory` before loading no-littering!
  (setq user-emacs-directory (expand-file-name "~/.cache/emacs/")
        url-history-file     (expand-file-name "url/history" user-emacs-directory))
  
  (use-package no-littering
    :straight t)
  
  ;; no-littering doesn't set this by default so we must place
  ;; auto save files in the same path as it uses for sessions
  (setq auto-save-file-name-transforms
        `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
  
  ;; Emacs saves all customizations in init.el by default. I prefer
  ;; to keep the customizations in a seperate file
  (setq custom-file (no-littering-expand-etc-file-name "custom.el"))
  
#+end_src

** Update Load Path

This is the folder which among others contains the desktop library.

#+begin_src emacs-lisp
  
  (push "~/.dotfiles/.emacs.d/lisp" load-path)
  
#+end_src

** Server-mode

Start the Emacs server from this instance so that all =emacsclient= calls are routed here.

#+begin_src emacs-lisp
  
  (server-start)
  
#+end_src

** Desktop

Load up the desktop environment if on a machine that supports it and the --use-exwm argument was passed to Emacs on startup. Desktop environment and window management code can be found in Desktop.org.

#+begin_src emacs-lisp
  (setq mb/exwm-enabled (eq window-system 'x))

  (when mb/exwm-enabled
    (require 'mb-desktop))
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  epkgs.exwm
  desktop-environment
#+end_src

** UI
*** Basic

Set some personal information

#+begin_src emacs-lisp
  
  (setq user-full-name "Mark Broeders"
        user-mail-address "mail@markBroeders.nl")
  
#+end_src

Clean up Emacs' user interface, make it more minimal.

#+begin_src emacs-lisp
  
  ;; Thanks, but no thanks
  (setq inhibit-startup-message t)
  
  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (menu-bar-mode -1)            ; Disable the menu bar
  (tooltip-mode -1)           ; Disable tooltips
  
  (set-fringe-mode 10)       ; Give some breathing room
  
  ;; Set up the visible bell
  (setq visible-bell t)
  
#+end_src

Improve scrolling.

#+begin_src emacs-lisp
  
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
  (setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
  (setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
  (setq scroll-step 1) ;; keyboard scroll one line at a time
  (setq use-dialog-box nil) ;; Disable dialog boxes since they weren't working in Mac OSX
  
#+end_src

Set frame transparency and maximize windows by default.

#+begin_src emacs-lisp
  
  (set-frame-parameter (selected-frame) 'alpha '(92 . 92))
  (add-to-list 'default-frame-alist '(alpha . (90 . 90)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  
#+end_src

Enable line numbers and customize their format.

#+begin_src emacs-lisp
  
  (global-display-line-numbers-mode t)
  (column-number-mode)
  
  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  org-agenda-mode-hook
                  term-mode-hook
                  erc-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  vterm-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))
  
#+end_src

Don't warn for following symlinked files

#+begin_src emacs-lisp
  
  (setq vc-follow-symlinks t)
  
#+end_src

Be more granular with undo

#+begin_src emacs-lisp
  
  (setq evil-want-fine-undo t)
  
#+end_src

Replace "yes" or "No" questions with "y" or "n"

#+begin_src emacs-lisp
  
  (fset 'yes-or-no-p 'y-or-n-p)
  
#+end_src

*** Themes

I really like the [[https://github.com/hlissner/emacs-doom-themes][Doom themes collection]], especially =vibrant= and =palenight=. For now, lets go with the former. Note that the function =doom-themes-visual-bell-config= enables flashing the mode-line on error.

#+begin_src emacs-lisp
  
  (use-package doom-themes
    :init
    (load-theme 'doom-palenight t)
    (doom-themes-visual-bell-config))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  doom-themes
#+end_src

*** Font

Different platforms need different default font sizes; [[https://mozilla.github.io/Fira/][Fira Mono]] was my favorite face, but I'm trying out =Jetbrains Mono= atm.

#+begin_src emacs-lisp
  
  ;; Set the font face based on platform
  (set-face-attribute 'default nil
                      :font "JetBrains Mono"
                      :weight 'light
                      :height 115)
  
  ;; Set the fixed pitch face
  (set-face-attribute 'fixed-pitch nil
                      :font "JetBrains Mono"
                      :weight 'light
                      :height 115)
  
  ;; Set the variable pitch face
  (set-face-attribute 'variable-pitch nil
                      :font "Cantarell"
                      ;;:font "Iosevka Aile"
                      :height 135
                      :weight 'light)
  
#+end_src

*** Modeline

For modeline customization there is =Doom Modeline= which allows for extensive [[https://github.com/seagle0128/doom-modeline#customize][customization]]. Below is a pretty basic configuration. It does however require the installation of all-the-icons font: =M-x all-the-icons-install-fonts=.

#+begin_src emacs-lisp
  
  (use-package all-the-icons)
  
  (use-package doom-modeline
    :after eshell
    :init
    (doom-modeline-mode 1)
    :custom
    (doom-modeline-height 20)
    (doom-modeline-bar-width 6)
    (doom-modeline-major-mode-icon nil))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  doom-modeline
    all-the-icons
#+end_src

*** Auto-Reverting Changed Files

#+begin_src emacs-lisp
  
  ;; Revert Dired and other buffers
  (setq global-auto-revert-non-file-buffers t)
  
  ;; Revert buffers when the underlying file has changed
  (global-auto-revert-mode 1)
  
#+end_src

*** Rainbow Coloured Parentheses

#+begin_src emacs-lisp
  
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
  
  ;; (use-package smartparens
  ;;   :hook (prog-mode . smartparens-mode))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  smartparens
    rainbow-delimiters
#+end_src

*** Highlight Matching Braces

#+begin_src emacs-lisp
  
  (use-package paren
    :config
    (set-face-attribute 'show-paren-match-expression nil :background "#363e4a")
    (show-paren-mode 1))
  
#+end_src

*** Set default browser in Emacs

#+begin_src emacs-lisp
  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "qutebrowser")
#+end_src

*** Pinentry

Emacs can be prompted for the PIN of GPG private keys, we just need to set
=epa-pinentry-mode= to accomplish that:

#+begin_src emacs-lisp
  
  (use-package pinentry)
  (setq epa-pinentry-mode 'loopback)
  (pinentry-start)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-elpa
  pinentry
#+end_src

*NOTE* Also install pinentry-emacs!

** Window Management

*** Frame Scaling / Zooming

The keybindings for this are =C+M+-= and =C+M+==.

#+begin_src emacs-lisp
  
  (use-package default-text-scale
    :defer 1
    :config
    (default-text-scale-mode))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  default-text-scale
#+end_src

** Evil Centered Keyboard Configuration

Although not as experienced as most people, I started out with vim. Although my switch to =Emacs= wasn't that bad (I never experienced an /Emacs pinky/), I still mostly prefer the [[https://vim.rtorr.com/][Vim keybindings]]. So, [[https://github.com/emacs-evil/evil][Evil]] to the rescue!

First, make =escape= quit prompts

#+begin_src emacs-lisp
  
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  
#+end_src

Since I let =evil-mode= take over =C-u= for buffer scrolling, I need to re-bind the =universal-argument= command to another key sequence.  I'm choosing =C-M-u= for this purpose.

#+begin_src emacs-lisp
  
  (global-set-key (kbd "C-M-u") 'universal-argument)
  
#+end_src

*** General

[[https://github.com/noctuid/general.el][General.el]] is a fantastic package that makes it very easy to create keybindings. One of the things I enjoyed from [[https://github.com/hlissner/doom-emacs][Doom Emacs]] was the =spacebar= as =leader-key=. In this little configuration snippet, I create a function which defines my leader key. This function makes it easy to create keybindings in my config. Note that my main leader-key is =SPC=, however, for easy configuration of extra keybindings I define a second one =C-c=.

#+begin_src emacs-lisp
  
  (use-package general
    :after evil
    :config
  
    (general-create-definer mb/leader-key-def
      :keymaps '(normal insert visual emacs)
      :prefix "SPC"
      :global-prefix "C-SPC")
  
    (general-create-definer mb/local-leader-keys
      :prefix "C-c"))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  general
#+end_src

*** Evil

Evil emulates the keybindings in Emacs and allows for extensive [[https://evil.readthedocs.io/en/latest/index.html][customization]]. Below is a pretty standard and simple configuration. Since =Evil= does not cover all the parts of Emacs, we use an extra package called [[https://github.com/emacs-evil/evil-collection][evil-collection]] which is a collection of additional keybindings for these parts that are not covered by Evil.

#+begin_src emacs-lisp
  
  (use-package undo-tree
    :init
    (global-undo-tree-mode 1))
  
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
  
    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
    ;; Same for up/down keys
    (define-key evil-normal-state-map (kbd "<down>") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "<up>") 'evil-previous-visual-line)
  
    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
  
  (use-package evil-collection
    :after evil
    :init
    (setq evil-collection-company-use-tng nil)  ;; Is this a bug in evil-collection?
    :config
    (evil-collection-init))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  evil
    evil-collection  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-elpa
  undo-tree
#+end_src

*** Which-key

[[https://github.com/justbur/emacs-which-key][Which-key]] is great for getting an overview of what keybindings are available
based on the prefix keys you entered. I set the delay quite low to 0.3 seconds. Increase this time to wait longer for the popup window.

#+begin_src emacs-lisp
  
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  which-key
#+end_src

*** Extra keybindings

Some extra keybindings which I'm quite used to:
- Bind =C-c a= to org-agenda
- Bind =C-c c= to org-capture
- Use =M-return= to open =ansi-term=
- Open ~mu4e~ with =C-c m=
- Create a 'toggle' prefix

#+begin_src emacs-lisp
  
  (mb/local-leader-keys
    "a"   '(org-agenda          :which-key "Open org-agenda")
    "c"   '(org-capture         :which-key "Capture item")
  
    "m"   '(mu4e                :which-key "Open mail")
    )
  
  (mb/leader-key-def
    ;; APPLICATIONS
    "a"  '(:ignore t   :which-key "Applications")
  
    "d"   '(:ignore t           :which-key "deft")
    "d d" '(deft                :which-key "deft")
    "d f" '(deft-find-file      :which-key "find file")
    "d n" '(deft-new-file-named :which-key "new file")
  
    "j"  '(:ignore t                             :which-key "Journal")
    "jj" '(org-journal-new-entry                 :which-key "New entry")
    "jo" '(org-journal-open-current-journal-file :which-key "Open current")
  
    ;; GTD / ORG FILES
    "o"    '(:ignore t :which-key "Open file")
    "o b"  '((lambda () (interactive)
               (find-file "~/Documents/org/gtd/books.org"))    :which-key "Books.org")
    "o i"  '((lambda () (interactive)
               (find-file "~/Documents/org/gtd/inbox.org"))    :which-key "Inbox.org")
    "o n"  '((lambda () (interactive)
               (find-file "~/Documents/org/gtd/main.org"))     :which-key "Notes.org")
    "o p"  '((lambda () (interactive)
               (find-file "~/Documents/org/gtd/projects.org")) :which-key "Projects.org")
  
    ;; TOGGLES
    "t"  '(:ignore t   :which-key "Toggles")
    )
  
#+end_src

** Editing Configuration
*** Tab Widths and Spaces For Indentation

Default to an indentation size of 2 spaces since it's the norm for pretty much every language I use.

#+begin_src emacs-lisp
  
  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  
#+end_src

And use spaces for indentation instead of the default tabs.

#+begin_src emacs-lisp
  
  (setq-default indent-tabs-mode nil)
  
#+end_src

*** Commenting Lines

[[https://github.com/emacsmirror/evil-nerd-commenter][Evil-nerd-commenter]] makes it much more efficient to comment lines out. See their Github for examples of practical usage.

#+begin_src emacs-lisp
  
  (use-package evil-nerd-commenter
    :bind ("M-/" . evilnc-comment-or-uncomment-lines))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  evil-nerd-commenter
#+end_src

*** Automatically clean whitespace

#+begin_src emacs-lisp
  
  (use-package ws-butler
    :hook ((text-mode . ws-butler-mode)
           (prog-mode . ws-butler-mode)))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  ws-butler
#+end_src

** File-Management
*** Dired

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][Dired]] is a built-in file manager for Emacs that does some pretty amazing things! I copied the next part from the emacs-from-scratch config, because it is so helpful. Here are some key bindings you should try out:

**** Key Bindings

***** Navigation

*Emacs* / *Evil*
- =n= / =j= - next line
- =p= / =k= - previous line
- =j= / =J= - jump to file in buffer
- =RET= - select file or directory
- =^= - go to parent directory
- =S-RET= / =g O= - Open file in "other" window
- =M-RET= - Show file in other window without focusing (previewing files)
- =g o= (=dired-view-file=) - Open file but in a "preview" mode, close with =q=
- =g= / =g r= Refresh the buffer with =revert-buffer= after changing configuration (and after filesystem changes!)

***** Marking files

- =m= - Marks a file
- =u= - Unmarks a file
- =U= - Unmarks all files in buffer
- =* t= / =t= - Inverts marked files in buffer
- =% m= - Mark files in buffer using regular expression
- =*= - Lots of other auto-marking functions
- =k= / =K= - "Kill" marked items (refresh buffer with =g= / =g r= to get them back)
- Many operations can be done on a single file if there are no active marks!

***** Copying and Renaming files

- =C= - Copy marked files (or if no files are marked, the current file)
- Copying single and multiple files
- =U= - Unmark all files in buffer
- =R= - Rename marked files, renaming multiple is a move!
- =% R= - Rename based on regular expression: =^test= , =old-\&=

*Power command*: =C-x C-q= (=dired-toggle-read-only=) - Makes all file names in the buffer editable directly to rename them!  Press =Z Z= to confirm renaming or =Z Q= to abort.

***** Deleting files

- =D= - Delete marked file
- =d= - Mark file for deletion
- =x= - Execute deletion for marks
- =delete-by-moving-to-trash= - Move to trash instead of deleting permanently

***** Creating and extracting archives

- =Z= - Compress or uncompress a file or folder to (=.tar.gz=)
- =c= - Compress selection to a specific file
- =dired-compress-files-alist= - Bind compression commands to file extension

***** Other common operations

- =T= - Touch (change timestamp)
- =M= - Change file mode
- =O= - Change file owner
- =G= - Change file group
- =S= - Create a symbolic link to this file
- =L= - Load an Emacs Lisp file into Emacs

**** Configuration

#+begin_src emacs-lisp
  
  (use-package dired
    :straight nil
    :commands (dired dired-jump)
    :bind (("C-x C-j" . dired-jump))
    :custom ((dired-listing-switches "-agho --group-directories-first"))
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "h" 'dired-single-up-directory
      "l" 'dired-single-buffer))
  
  (use-package dired-single
    :commands (dired dired-jump))
  
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
  
  (use-package dired-open
    :commands (dired dired-jump)
    :config
    ;; Doesn't work as expected!
    ;;(add-to-list 'dired-open-functions #'dired-open-xdg t)
    (setq dired-open-extensions '(("png" . "feh")
                                  ("pdf" . "zathura")
                                  ("mkv" . "mpv"))))
  
  (use-package dired-hide-dotfiles
    :straight t
    :hook (dired-mode . dired-hide-dotfiles-mode)
    :config
    (evil-collection-define-key 'normal 'dired-mode-map
      "H" 'dired-hide-dotfiles-mode))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  dired-single
    dired-hacks-utils
    all-the-icons-dired
#+end_src

** Development
*** Productivity
**** Syntax checking with Flycheck

#+begin_src emacs-lisp
  
  (use-package flycheck
    :defer t
    :hook (lsp-mode . flycheck-mode))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  flycheck
#+end_src

**** Snippets

See [[https://github.com/joaotavora/yasnippet][github]] for more info.

#+begin_src emacs-lisp
  
  (use-package yasnippet
    ;; Disabled, because I'm using it globally
    ;; :hook (prog-mode . yas-minor-mode)
    :config
    (setq yas-snippet-dirs '("~/Development/emacs-projects/snippets"))
    (yas-global-mode 1)
    (yas-reload-all))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  yasnippet
    yasnippet-snippets
#+end_src

*** Projectile

#+begin_src emacs-lisp
  
  (use-package projectile
    :config (projectile-mode)
    :demand t
    :init
    (setq projectile-project-search-path (list "~/Development/"
                                               "~/Documents/org/notes/")))
  
  (mb/leader-key-def
    "p"   '(:ignore t                  :which-key "Projectile")
    "pf"  'projectile-find-file
    "pp"  'projectile-switch-project
    "pF"  'consult-ripgrep
    "pd"  'projectile-dired)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  projectile
    ripgrep
#+end_src

*** Magit

https://magit.vc/manual/magit/

#+begin_src emacs-lisp
  
  (use-package magit
    :bind
    ("C-x g" . magit)
    :commands (magit-status magit-get-current-branch)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  magit
#+end_src

*** Languages
**** IDE Features with lsp-mode
***** lsp-mode

We use the excellent [[https://emacs-lsp.github.io/lsp-mode/][lsp-mode]] to enable IDE-like functionality for many different programming languages via "language servers" that speak the [[https://microsoft.github.io/language-server-protocol/][Language Server Protocol]].  Before trying to set up =lsp-mode= for a particular language, check out the [[https://emacs-lsp.github.io/lsp-mode/page/languages/][documentation for your language]] so that you can learn which language servers are available and how to install them.

The =lsp-keymap-prefix= setting enables you to define a prefix for where =lsp-mode='s default keybindings will be added.  I *highly recommend* using the prefix to find out what you can do with =lsp-mode= in a buffer.

The =which-key= integration adds helpful descriptions of the various keys so you should be able to learn a lot just by pressing =C-c l= in a =lsp-mode= buffer and trying different things that you find there.

#+begin_src emacs-lisp
  
  (defun efs/lsp-mode-setup ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (lsp-headerline-breadcrumb-mode))
  
  (use-package lsp-mode
    :commands (lsp lsp-deferred)
    :hook (lsp-mode . efs/lsp-mode-setup)
    :init
    (setq lsp-keymap-prefix "C-c l")  ;; Or 'C-l', 's-l'
    :config
    (lsp-enable-which-key-integration t))
  
#+end_src

***** lsp-ui

[[https://emacs-lsp.github.io/lsp-ui/][lsp-ui]] is a set of UI enhancements built on top of =lsp-mode= which make Emacs feel even more like an IDE.  Check out the screenshots on the =lsp-ui= homepage (linked at the beginning of this paragraph) to see examples of what it can do.

#+begin_src emacs-lisp
  
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-doc-position 'bottom))
  
#+end_src

***** lsp-treemacs

[[https://github.com/emacs-lsp/lsp-treemacs][lsp-treemacs]] provides nice tree views for different aspects of your code like symbols in a file, references of a symbol, or diagnostic messages (errors and warnings) that are found in your code.

Try these commands with =M-x=:

- =lsp-treemacs-symbols= - Show a tree view of the symbols in the current file
- =lsp-treemacs-references= - Show a tree view for the references of the symbol under the cursor
- =lsp-treemacs-error-list= - Show a tree view for the diagnostic messages in the project

This package is built on the [[https://github.com/Alexander-Miller/treemacs][treemacs]] package which might be of some interest to you if you like to have a file browser at the left side of your screen in your editor.

#+begin_src emacs-lisp :tangle no
  
  (use-package lsp-treemacs
    :after lsp)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  lsp-mode
    lsp-ui
    lsp-treemacs
#+end_src

**** Better Completions with Company Mode

#+begin_src emacs-lisp
  
  (use-package company
    :after lsp-mode
    :hook (prog-mode . company-mode)
    :bind (:map company-active-map
                ("<tab>" . company-complete-selection))
    (:map lsp-mode-map
          ("<tab>" . company-indent-or-complete-common))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  company
#+end_src

**** Debugging with dap-mode

*NOTE* Disabled for the moment as I'm trying out =eglot=

[[https://emacs-lsp.github.io/dap-mode/][dap-mode]] is an excellent package for bringing rich debugging capabilities to Emacs via the [[https://microsoft.github.io/debug-adapter-protocol/][Debug Adapter Protocol]]. You should check out the [[https://emacs-lsp.github.io/dap-mode/page/configuration/][configuration docs]] to learn how to configure the debugger for your language.  Also make sure to check out the documentation for the debug adapter to see what configuration parameters are available to use for your debug templates!

#+begin_src emacs-lisp :tangle no
  
  (use-package dap-mode
    ;; Uncomment the config below if you want all UI panes to be hidden by default!
    ;; :custom
    ;; (lsp-enable-dap-auto-configure nil)
    ;; :config
    ;; (dap-ui-mode 1)
  
    :config
    ;; Set up Node debugging
    (require 'dap-node)
    (dap-node-setup) ;; Automatically installs Node debug adapter if needed
  
    ;; Bind `C-c l d` to `dap-hydra` for easy access
    (general-define-key
     :keymaps 'lsp-mode-map
     :prefix lsp-keymap-prefix
     "d" '(dap-hydra t :wk "debugger")))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  dap-mode
#+end_src

**** Eglot as language server

*NOTE* Disabled as I'm having some difficulties with getting rust to work properly. Therefore back to =lsp-mode=.

[[https://github.com/joaotavora/eglot][Eglot]] is an alternative to =lsp-mode=. Check the documentation to find out [[https://github.com/joaotavora/eglot#connecting][which servers]] =eglot= can connect to out of the box. =Eglot= does not come with default keybindings, but you can easily bind stuff to certain [[https://github.com/joaotavora/eglot#commands][eglot commands]].

#+begin_src emacs-lisp :tangle no
  
  (use-package eglot
    :straight t)
  
#+end_src

**** Markdown

#+begin_src emacs-lisp
  
  (use-package markdown-mode
    :straight t
    :mode "\\.md\\'"
    :config
    (setq markdown-command "marked")
    (defun mb/set-markdown-header-font-sizes ()
      (dolist (face '((markdown-header-face-1 . 1.2)
                      (markdown-header-face-2 . 1.1)
                      (markdown-header-face-3 . 1.0)
                      (markdown-header-face-4 . 1.0)
                      (markdown-header-face-5 . 1.0)))
        (set-face-attribute (car face) nil :weight 'normal :height (cdr face))))
  
    (defun mb/markdown-mode-hook ()
      (mb/set-markdown-header-font-sizes))
  
    (add-hook 'markdown-mode-hook 'mb/markdown-mode-hook))
  
#+end_src

**** Nix

#+begin_src emacs-lisp
  
  (use-package nix-mode
    :straight t
    :mode "\\.nix\\'")
  
#+end_src

**** Python

We use =lsp-mode= and =dap-mode= to provide a more complete development environment for Python in Emacs.  Check out [[https://emacs-lsp.github.io/lsp-mode/page/lsp-pyls/][the =pyls= configuration]] in the =lsp-mode= documentation for more details.

Make sure you have the =pyls= language server installed before trying =lsp-mode=!

#+begin_src sh :tangle no
  
  pip install --user "python-language-server[all]"
  
#+end_src

There are a number of other language servers for Python so if you find that =pyls= doesn't work for you, consult the =lsp-mode= [[https://emacs-lsp.github.io/lsp-mode/page/languages/][language configuration documentation]] to try the others!

#+begin_src emacs-lisp
  
  (use-package python-mode
    :hook (python-mode . lsp-deferred)
    :custom
    ;; NOTE: Set these if Python 3 is called "python3" on your system!
    (python-shell-interpreter "python3")
    (dap-python-executable "python3")
    (dap-python-debugger 'debugpy)
    :config
    (require 'dap-python))
  
#+end_src

You can use the pyvenv package to use =virtualenv= environments in Emacs.  The =pyvenv-activate= command should configure Emacs to cause =lsp-mode= and =dap-mode= to use the virtual environment when they are loaded, just select the path to your virtual environment before loading your project.

#+begin_src emacs-lisp
  
  (use-package pyvenv
    :config
    (pyvenv-mode 1))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  pyvenv
#+end_src

**** Rust

[[https://github.com/brotzeit/rustic#straight][Rustic]] is a fork of [[https://github.com/rust-lang/rust-mode][rust-mode]]. For now, I copied the config from [[https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/#rustic][here]], but I will update this in the future to my liking.

#+begin_src emacs-lisp
  
  (use-package rustic
    :straight t
    :config
    (setq lsp-rust-analyzer-server-command '("~/.bin/rust-analyzer"))
    ;; comment to disable rustfmt on save
    (setq rustic-format-on-save t))
  
#+end_src

**** Scheme

#+begin_src emacs-lisp
  
  ;; Include .sld library definition files
  (use-package scheme-mode
    :straight nil
    :mode "\\.sld\\'")
  
  (use-package geiser
    :straight t
    :config
    ;; (setq geiser-default-implementation 'gambit)
    (setq geiser-default-implementation 'guile)
    (setq geiser-active-implementations '(gambit guile))
    (setq geiser-repl-default-port 44555) ; For Gambit Scheme
    (setq geiser-implementations-alist '(((regexp "\\.scm$") gambit)
                                         ((regexp "\\.sld") gambit))))
#+end_src

** Completion Framework

There are many packages which provide completion frameworks, such as =ivy= and =helm=. Recently, I started using =vertico=, =consult=, =marginalia= and others. These are somewhat /smaller/ since they are built upon basic functionality that Emacs already provides. It is important to have =ripgrep= installed as this is notably faster than standar =grep=.

*** Vertico

[[https://github.com/minad/vertico][Vertico]] is a relatively new package created by Minad which displays a minimalistic vertical compeletion UI. It is builts further upon the built-in functionality that Emacs provides. This makes it different from [[https://github.com/abo-abo/swiper][Ivy]] which is a complete generic completion system. Therefore, we have to custimize it a bit further. Below is the basic config as taken from github.

#+begin_src emacs-lisp
  
  ;; Enable vertico
  (use-package vertico
    :straight '(vertico :host github
                        :repo "minad/vertico"
                        :branch "main")
    :init
    (vertico-mode)
  
    ;; Optionally enable cycling for `vertico-next' and `vertico-previous'.
    ;; (setq vertico-cycle t)
    )
  
  ;; Use the `orderless' completion style.
  ;; Enable `partial-completion' for files to allow path expansion.
  ;; You may prefer to use `initials' instead of `partial-completion'.
  (use-package orderless
    :straight t
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles . (partial-completion))))))
  
  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))
  
#+end_src

*** Marginalia

[[https://github.com/minad/marginalia][Marginalia]] provides rich annotations. It is made by the same person who developed =Vertico= and many other useful packages. Marginalia for instance shows extra useful information in the minibuffer.

#+begin_src emacs-lisp
  
  ;; Enable richer annotations using the Marginalia package
  (use-package marginalia
    :after vertico
    :straight t
    ;; Either bind `marginalia-cycle` globally or only in the minibuffer
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))
  
    ;; The :init configuration is always executed (Not lazy!)
    :init
  
    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode))
  
#+end_src

*** Consult

#+begin_src emacs-lisp
  ;; Consult
  (use-package consult
    :straight t ;; Install with straight
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :bind (;; C-c bindings (mode-specific-map)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Isearch integration
           ("C-s" . consult-line)
           :map isearch-mode-map
           ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line))                 ;; required by consult-line to detect isearch
  
    ;; Enable automatic preview at point in the *Completions* buffer.
    ;; This is relevant when you use the default completion UI,
    ;; and not necessary for Selectrum, Vertico etc.
    :hook (completion-list-mode . consult-preview-at-point-mode)
  
    ;; The :init configuration is always executed (Not lazy)
    :init
  
    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)
  
    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)
  
    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
  
    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config
  
    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-ripgrep consult-git-grep consult-grep consult-bookmark consult-recent-file
     consult--source-file consult--source-project-file consult--source-bookmark
     :preview-key (kbd "M-."))
  
    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")
  
    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)
  
    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
    (setq consult-project-root-function
          (lambda ()
            (when-let (project (project-current))
              (car (project-roots project)))))
    ;;;; 2. projectile.el (projectile-project-root)
    ;; (autoload 'projectile-project-root "projectile")
    ;; (setq consult-project-root-function #'projectile-project-root)
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
    )
  
#+end_src

** Org Mode

=Org mode= is what makes Emacs most special; it's what drove me to Emacs and convinced me to stay. I discovered Emacs while reading [[https://gettingthingsdone.com/][Getting Things Done]] and both seemed to work really great together. Org comes with many different modules and functions, but works even better with some basic configuration.

*** Org UI

First, let's define a function for better fonts in =org files=. Make sure =Cantarell= fonts are installed.

#+begin_src emacs-lisp
  
  (defun mb/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
  
    ;; Set faces for heading levels
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))
  
    ;; Ensure that anything that should be fixed-pitch in Org files appears that way
    (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
    (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
    (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
    (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
    (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch))
  
#+end_src

Next, set up a function for org-mode hook. This makes sure:
- the buffer is displayed in the indented view
- we get /proportional fonts/ in the buffer, makes it nicer to look at
- /word-wrap/ is turned on and editing commands act on visual lines, not logical lines
- enable visual-fill

#+begin_src emacs-lisp
  
  (defun mb/org-mode-visual-fill ()
    (setq visual-fill-column-width 120
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))
  
  (use-package visual-fill-column
    :defer t)
  
  (defun mb/org-mode-setup ()
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    (mb/org-mode-visual-fill))
  
#+end_src

*** Configuration

Here, we start the actual configuration. The first part of the config sets-up various things, such as:

- A nicer symbol to show there is hidden content
- Hide emphasis markers so we see *bold* instead of **bold**
- Make sure at startup content is =folded=
- Extra =evil= key definitions

#+begin_src emacs-lisp
  
  (straight-use-package '(org :type built-in))
  
  (use-package org
    :defer t
    :hook (org-mode . mb/org-mode-setup)
    :config
    (setq org-ellipsis " ▾"
          org-hide-emphasis-markers t
          org-src-fontify-natively t
          org-fontify-quote-and-verse-blocks t
          org-src-tab-acts-natively t
          org-edit-src-content-indentation 2
          org-hide-block-startup nil
          org-src-preserve-indentation nil
          org-startup-folded 'content
          org-cycle-separator-lines 2)
  
    (evil-define-key '(normal insert visual) org-mode-map (kbd "C-j") 'org-next-visible-heading)
    (evil-define-key '(normal insert visual) org-mode-map (kbd "C-k") 'org-previous-visible-heading)
  
    (evil-define-key '(normal insert visual) org-mode-map (kbd "M-j") 'org-metadown)
    (evil-define-key '(normal insert visual) org-mode-map (kbd "M-k") 'org-metaup)
  
#+end_src

*NOTE* This is not the /end/ of our =use-package= block!

*** *NOTE* TESTING NEW WORKFLOW

So, the next few items have been disabled for now.

**** File paths

In this part I set some default paths.

#+begin_src emacs-lisp :tangle no
  
  (setq org-directory "~/Documents/org"
        org-roam-directory "~/Documents/org/notes"
        org-default-notes-file "~/Documents/org/notes/main.org"
        org-agenda-files '( "~/Documents/org/calendar/personal.org"
                            "~/Documents/org/calendar/family.org"
                            "~/Documents/org/gtd/inbox.org"))
  
#+end_src

**** Workflow states

In our workflow part of this configuration, I set up my =TODO= keywords. You can add multiple =keyword sequences= to the list. I use one for my default workflow and one for my book log.

=!= means to add a time
=@= ask for note

Furthermore, it's nice to have the keywords visually emphasized using different colours.

#+begin_src emacs-lisp :tangle no
  
  (setq org-todo-keywords
        '((sequence "TODO(t)" "NEXT(n)" "WAITING(w@/!)" "CANCELLED(c@/!" "|" "DONE(d!)")
          (sequence "PLANNED(p)" "READING(r)" "|" "DONE(d!)" "CANC(k@")))
  
  (setq org-todo-keyword-faces
        '(("NEXT"      . (:foreground "orange red"    :weight bold))
          ("TODO"      . (:foreground "orange red"    :weight bold))
          ("WAITING"   . (:foreground "HotPink2"      :weight bold))
          ("CANCELLED" . (:foreground "red"           :weight bold))
          ("DONE"      . (:foreground "MediumPurple3" :weight bold))))
  
#+end_src

**** Tags

Tags are nice to quickly filter out certain actions.

#+begin_src emacs-lisp :tangle no
  
  (setq org-tag-alist
        '(("@COMPUTER" . ?C)
          ("@HOME"     . ?H)
          ("@WORK"     . ?W)
          ("@PHONE"    . ?t)
          ("project"   . ?p)
          ("habit"     . ?h)
          ("idea"      . ?i)))
#+end_src

**** Agenda

With =org agenda= you can [[https://orgmode.org/manual/Agenda-Views.html#Agenda-Views][customize]] your whole agenda look, but for now I keep it simple. In the future, I'd like to dive into [[https://github.com/alphapapa/org-super-agenda][org-super-agenda]].

#+begin_src emacs-lisp :tangle no
  
  ;; Configure custom agenda views
  (setq org-agenda-custom-commands
        '(("d" "Dashboard"
           ((agenda "" ((org-deadline-warning-days 7)))
            (todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))
            (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))
  
          ("n" "Next Tasks"
           ((todo "NEXT"
                  ((org-agenda-overriding-header "Next Tasks")))))))
  
#+end_src

**** Capture templates

=Org-capture= make it very easy to quickly store notes and other things. It has [[https://orgmode.org/manual/Capture.html#Capture][way too many possibilities to remember]], but below are a couple of useful templates. I still have some cleaning-up to do.

#+begin_src emacs-lisp :tangle no
  
  (setq org-capture-templates
        `(("t" "Tasks / Projects")
          ("tn" "Next Item" entry
           (file+olp "~/Documents/org/gtd/inbox.org" "Tasks")
           "* NEXT %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("tt" "TODO" entry
           (file+olp "~/Documents/org/gtd/inbox.org" "Tasks")
           "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)
          ("tp" "Project" entry
           (file+headline "~/Documents/org/gtd/projects.org" "PROJECTEN")
           "* PROJ %?\n %U\n %i" :empty-lines 1)
  
          ("w" "Review: Weekly Review" entry (file+datetree "~/Documents/org/gtd/reviews.org")
           (file "~/Documents/org/templates/weeklyreviewtemplate.org")
           :immediate-finish :jump-to-captured)
  
          ("m" "Metrics Capture / Sports")
          ("mc" "Fietsen" table-line
           (file+headline "~/Documents/org/gtd/metrics.org" "Cycling")
           "| %U | %^{Distance} | %^{Avg speed} | %^{Duration} | %^{Avg heartrate} | %^{Notes} |" :kill-buffer t)
          ("mr" "Hardlopen" table-line
           (file+headline "~/Documents/org/gtd/metrics.org" "Running"))
          ("mw" "Weight" table-line
           (file+headline "~/Documents/org/gtd/metrics.org" "Weight")
           "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)
  
          ("e" "Email Workflow")
          ("ee" "Checking Email" entry
           (file+olp+datetree "~/Documents/org/gtd/journal.org")
           "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)
          ("ef" "Follow Up" entry (file+headline "~/Documents/org/gtd/mail.org" "Follow-up")
           "* TODO Follow up with %:fromname on %:subject\n%a\n\n%i")
          ("er" "Read Later" entry (file+headline "~/Documents/org/gtd/mail.org" "Read Later")
           "* TODO Read %:subject\n%a\n\n%i")
  
          ("h" "Hobbies")
          ("hb" "Book entry" entry (file+headline "~/Documents/org/gtd/books.org" "2021")
           "* %^{prompt|TODO|READING|DONE} %^{Title}\n:PROPERTIES:\n:author: %?\n:END:\n" :prepend t :empty-lines-after 1)))
  
#+end_src

**** *New Workflow*

#+begin_src emacs-lisp
  
  (require 'mb-workflow)
  
#+end_src

*** Modules

Enable some modules which are quite handy, such as =habits=

#+begin_src emacs-lisp
  
  (setq org-modules
        '(org-habit
          org-bookmark
          org-eshell))
  
#+end_src

*** Babel

=Babel= is amazing! It /tangles/ all source code blocks into a different document, but can do so much more. I just have to set it up for my languages. It's easy to add [[https://orgmode.org/worg/org-contrib/babel/languages/index.html][languages]].

#+begin_src emacs-lisp
  
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (python . t)))
  
  (push '("conf-unix" . conf-unix) org-src-lang-modes)
  (push '("nix" . nix) org-src-lang-modes)
  
#+end_src

*** Block Templates

These templates enable you to type things like =<el= and then hit =Tab= to expand
the template. More documentation can be found at the Org Mode [[https://orgmode.org/manual/Easy-templates.html][Easy Templates]]
documentation page.

#+begin_src emacs-lisp

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("r"  . "src rust"))

#+end_src

*** Org Bullets using Superstar

The default heading stars are not very visually attractive. I replace this with [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]] and define a custom bullet list.

#+begin_src emacs-lisp

  (use-package org-superstar
    :straight t
    :after org
    :hook (org-mode . org-superstar-mode)
    :custom
    (org-superstar-remove-leading-stars t)
    (org-superstar-headline-bullets-list '("◉" "○" "●" "○" "●" "○" "●")))

#+end_src

*** Archiving Made Easier - Function

Add a little function that makes it easier to archive all =DONE= items in a subtree (without archiving the entire subtree). See: [[https://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command][stackoverflow]]

#+begin_src emacs-lisp
  
  (defun org-archive-done-tasks ()
    (interactive)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
     "/DONE" 'tree))
  
#+end_src

*** Update Table of Contents on Save

It's nice to have a table of contents section for long literate configuration files (like this one!) so I use =org-make-toc= to automatically update the ToC in any header with a property named =TOC=.

#+begin_src emacs-lisp
  
  (use-package org-make-toc
    :hook (org-mode . org-make-toc-mode))
  
#+end_src

*** End of =use-package org=

And finally, load our font setup (see function at the beginning of this org block) and end our =use-package org= block with a parenthesis.

#+begin_src emacs-lisp
  
  (mb/org-font-setup))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-org
  org
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  org-bullets
    org-appear
    evil-org
    org-make-toc
    deft
    org-re-reveal
    visual-fill-column
#+end_src

** Org Journal

It is my intention to use a journal to indicate how my day was, how I was feeling, whether I was tired and more. This should be a habit I suppose. [[https://github.com/bastibe/org-journal][Org-journal]] might be a useful package for this, so I'll try using it with a very basic configuration.

#+begin_src emacs-lisp
  
  (use-package org-journal
    :defer t
    :config
    (setq org-journal-dir "~/Documents/org/journals/"
          org-journal-date-format "%A, %d %B %Y"
          org-journal-file-type 'weekly))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  org-journal
#+end_src

** Sync Google Calendar

I mainly use Google Calendar (one of my last Google apps), and I would like to show my appointments in Org calendar. For this, I've used =org-gcal=, but had some problems with it. So, now I'll try [[https://github.com/dengste/org-caldav][org-caldav]].

*NOTE* I have to defer this for 2 minutes, because somehow =:after= does not work.

#+begin_src emacs-lisp
  
  (use-package oauth2) ;; needed for Caldav
  
  (use-package org-caldav
    :defer 120 ;; Wait 2 minutes!
    :config
    (setq org-caldav-oauth2-client-id (password-store-get "API/Google/gcal-client-id"))
    (setq org-caldav-oauth2-client-secret (password-store-get "API/Google/gcal-client-secret"))
    (setq org-caldav-url 'google)
    (setq org-caldav-calendars
          '((:calendar-id "mbroeders@gmail.com"
                          :files ("~/Documents/org/gtd/inbox.org")   ;; Files needed to sync TO Google Calendar
                          :inbox "~/Documents/org/calendar/personal.org")    ;; Here go all the new entries
            (:calendar-id "family08361847864604318057@group.calendar.google.com"
                          :files ()
                          ;; :skip-conditions (regexp "soccer")
                          :inbox "~/Documents/org/calendar/family.org"))
          )
    (setq org-icalendar-timezone "Europe/Amsterdam")
    (setq org-caldav-save-directory "~/Documents/org/calendar/")
    (setq plstore-cache-passphrase-for-symmetric-encryption t))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  org-caldav
    oauth2-request
#+end_src

** Presentations with =org-re-reveal=

I recently discovered [[https://github.com/emacsmirror/org-re-reveal][org-re-reveal]], a package with which you can create simple, yet beautiful presentations. I'm going to try this out in my next presentations. For now, I don't really set custom variables, but to make sure Emacs loads the library, I'll add a =require= block.

#+begin_src emacs-lisp

  (require 'org-re-reveal)

#+end_src


** Useful Packages and Apps
*** App Launcher

#+begin_src emacs-lisp
  
  (use-package app-launcher
    :straight '(app-launcher :host github :repo "SebastienWae/app-launcher"))
  
#+end_src

*** Deft (note taking)

[[https://jblevins.org/projects/deft/][deft]] is an Emacs mode for quickly browsing, filtering, and editing directories of plain text notes.

#+begin_src emacs-lisp
  
  (use-package deft
    :commands (deft)
    :config (setq deft-directory "~/Documents/org/notes"
                  deft-default-extension "org"
                  deft-extensions '("md" "org")))
  
#+end_src

*** ERC (chat)

So, although I come from the 80's and have used =msm= in the past, I never really used chat engines. But, [[https://systemcrafters.cc/][System Crafters]] made me curious about [[https://www.gnu.org/software/emacs/manual/html_mono/erc.html][ERC]] thanks to [[https://systemcrafters.cc/chatting-with-emacs/irc-basics-with-erc/][this video]]. Therefore, I copied the basic config and am going to try it out.

Some basic commands:
- =/join #CHANNEL= to join a channel, =/part= to leave
- =/list= to list all channels
- =/reconnect= to reconnect, sometimes necessary after suspend

**** Connect automatically with =C-c c=

First, let's define a function to automatically connect to a specific server. This is bound to =C-c c c=.

#+begin_src emacs-lisp
  
  (defun mb/connect-irc ()
    (interactive)
    (erc-tls
     :server "irc.libera.chat"
     :port 6697
     :nick "marbro81"
     ;; This is using password-store.el.  Not needed if you use auth-source!
     :password (password-store-get "web/libera.chat")))
  
  (global-set-key (kbd "C-c e e") 'mb/connect-irc)
  
#+end_src

**** Basic Configuration

Below are some basic settings, for instance: set my full name, hide some messages, connect automatically to some channels and more.

#+begin_src emacs-lisp
  
  (setq erc-user-full-name "Mark Broeders"  ; And this!
        erc-hide-list '("JOIN" "PART" "QUIT")
        erc-track-shorten-start 8
        erc-autojoin-channels-alist '(("irc.libera.chat" "#systemcrafters" "#emacs"))
        erc-kill-buffer-on-part t
        erc-auto-query 'bury)
  
#+end_src

**** Jumping IRC Buffers Easily

Two commands are useful for jumping to IRC buffers easily:
- erc-switch-to-buffer
- erc-track-switch-buffer (bound to =C-c C-SPC= if =erc-track-enable-keybindings= is =t=)

#+begin_src emacs-lisp
  
  (setq erc-track-enable-keybindings t)
  
#+end_src

**** Colorize Nicks

#+begin_src emacs-lisp
  
  (use-package erc-hl-nicks
    :after erc
    :config
    (add-to-list 'erc-modules 'hl-nicks))
  
#+end_src

**** Display Inline Images

#+begin_src emacs-lisp
  
  (use-package erc-image
    :after erc
    :config
    (setq erc-image-inline-rescale 300)
    (add-to-list 'erc-modules 'image))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  erc-image
    erc-hl-nicks
#+end_src

*** Expand Region

This module is absolutely necessary for working inside of Emacs Lisp files,
especially when trying to some parent of an expression (like a =setq=).  Makes
tweaking Org agenda views much less annoying.

#+begin_src emacs-lisp
  
  (use-package expand-region
    :bind (("M-[" . er/expand-region)
           ("C-(" . er/mark-outside-pairs)))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  expand-region
#+end_src

*** Helpful

[[https://github.com/Wilfred/helpful][Helpful]] is a very helpful package that aims to be an alternative for the built-in and provides much more contextual information. For instance, in addition to the basic documentation, you will also see the source code of the function and where it gets used in other places in the Emacs configuration. It is very useful for figuring out how things work in Emacs.

#+begin_src emacs-lisp
  
  (use-package helpful
    :config
    ;; Note that the built-in `describe-function' includes both functions
    ;; and macros. `helpful-function' is functions only, so we provide
    ;; `helpful-callable' as a drop-in replacement.
    (global-set-key (kbd "C-h f") #'helpful-callable)
  
    (global-set-key (kbd "C-h v") #'helpful-variable)
    (global-set-key (kbd "C-h k") #'helpful-key)
  
    ;; Look up *F*unctions (excludes macros).
    ;;
    ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful
    ;; already links to the manual, if a function is referenced there.
    (global-set-key (kbd "C-h F") #'helpful-function)
  
    ;; Look up *C*ommands.
    ;;
    ;; By default, C-h C is bound to describe `describe-coding-system'. I
    ;; don't find this very useful, but it's frequently useful to only
    ;; look at interactive functions.
    (global-set-key (kbd "C-h C") #'helpful-command))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  helpful
#+end_src

*** Mail

My mail configuration is stored in [[file:Mail.org][Mail.org]].  We merely require it here to have it loaded in the main Emacs configuration.

#+begin_src emacs-lisp
  
  (require 'mb-mail)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  mu4e-alert
#+end_src

*** Notifications

A basic [[https://github.com/jwiegley/alert][common notification interface]] for Emacs.

#+begin_src emacs-lisp
  
  (use-package alert
    :commands alert
    :config
    (setq alert-default-style 'notifications))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  alert
#+end_src

*** Text Scaling using Hydra

This part is completely copied from emacs-from-scratch, because I still have to figure out what [[https://github.com/abo-abo/hydra][hydra]] exactly does.

This is an example of using Hydra to design a transient key binding for quickly adjusting the scale of the text on screen. We define a hydra that is bound to =SPC t s= and, once activated, =j= and =k= increase and decrease the text scale. You can press any other key (or f specifically) to exit the transient key map.

#+begin_src emacs-lisp
  
  (use-package hydra
    :defer 1)
  
  (defhydra hydra-text-scale (:timeout 4)
    "scale text"
    ("j" text-scale-increase "in")
    ("k" text-scale-decrease "out")
    ("f" nil "finished" :exit t))
  
  (mb/leader-key-def
    "t s" '(hydra-text-scale/body :which-key "scale text"))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  hydra
#+end_src

** Terminals
*** Eshell

[[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]] is a shell-like command interpreter written in Emacs Lisp. I find it quite handy, although I'm not yet quite sure if, for me, it replaces the more /common/ terminals.

**** Configuration

#+begin_src emacs-lisp
  
  (use-package eshell
    :init
    (setq eshell-directory-name "~/.dotfiles/.emacs.d/eshell/"
          eshell-aliases-file (expand-file-name "~/.dotfiles/.emacs.d/eshell/alias")))
  
  (mb/leader-key-def
    "SPC" 'eshell)
  
#+end_src

**** Toggling Eshell

#+begin_src emacs-lisp
  
  (use-package eshell-toggle
    :bind ("C-M-'" . eshell-toggle)
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  eshell-toggle
    eshell-syntax-highlighting
#+end_src

*** Vterm

[[https://github.com/man9ourah/vterm][Vterm]] is a handy terminal emulator with many features. In Emacs, there is a package called [[https://github.com/akermu/emacs-libvterm][emacs-libvterm]] which brings vterm to Emacs. Check github for some useful configuration options.

#+begin_src emacs-lisp
  
  (use-package vterm
    :commands vterm
    :config
    (setq vterm-max-scrollback 10000))
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  emacs-libvterm
#+end_src

** Password Management

I use =pass= for password management, all the passwords are stored on my private server. In emacs, the =password= store package can import passwords into Emacs. It's also nice to have =+pass/ivy=, this makes it easy to retrieve a password from within Emacs.

#+begin_src emacs-lisp
  (use-package password-store
    :config
    (setq password-store-password-length 12))
  
  (use-package auth-source-pass
    :config
    (auth-source-pass-enable))
  
  (mb/leader-key-def
    "a p" '(:ignore t :which-key "pass")
    "a p p" 'password-store-copy
    "a p i" 'password-store-insert
    "a p g" 'password-store-generate)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  password-store
    # auth-source-pass
#+end_src

** System Utilities

*** Daemons

#+begin_src emacs-lisp
  
  (use-package daemons
    :commands daemons)
  
#+end_src

*Nix Packages*

#+begin_src nix :noweb-ref emacs-melpa
  daemons
#+end_src

*** Proced

Manage system processes with =proced.el=

#+begin_src emacs-lisp
  
  (use-package proced
    :commands proced
    :config
    (setq proced-auto-update-interval 1)
    (add-hook 'proced-mode-hook
              (lambda ()
                (proced-toggle-auto-update 1))))
  
#+end_src

** Runtime Performance

Dial the GC threshold back down so that garbage collection happens more frequently but in less time.

#+begin_src emacs-lisp
  
  ;; Make gc pauses faster by decreasing the threshold.
  (setq gc-cons-threshold (* 2 1000 1000))
  
#+end_src

** Inspiration

[[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]] has a good list of packages and themes to check out.

Other dotfiles repos and blog posts for inspiration:

- [[https://github.com/howardabrams/dot-files][Howard Abrams' dotfiles]]
- [[https://github.com/daedreth/UncleDavesEmacs/blob/master/config.org][UncleDave's Emacs config]]
- [[https://github.com/dakrone/dakrone-dotfiles][dakrone's dotfiles]]
- [[https://github.com/jinnovation/dotemacs][jinnovation dotemacs]]
- [[https://writequit.org/org/][writequit's config]]


* Dotfile Helper Scripts

Updating my dotfiles requires running a script in Emacs to loop over all of my literate configuration =.org= files and run =org-babel-tangle-file= to make sure all of my configuration files are up to date.

*.bin/update-dotfiles*

#+begin_src sh :tangle .bin/update-dotfiles :shebang #!/bin/sh :mkdirp yes

  # Navigate to the directory of this script (generally ~/.dotfiles/.bin)
  cd $(dirname $(readlink -f $0))
  cd ..

  # The heavy lifting is done by an Emacs script
  emacs -Q --script ./.emacs.d/tangle-dotfiles.el

  # Make sure any running Emacs instance gets updated settings
  emacsclient -e '(load-file "./.emacs.d/tangle-dotfiles.el")' -a "echo 'Emacs is not currently running'"

  # Update configuration symlinks
  stow .

#+end_src

*.emacs.d/tangle-dotfiles.el*

#+begin_src emacs-lisp :tangle .emacs.d/tangle-dotfiles.el

  (require 'org)
  ;; (load-file "~/.dotfiles/.emacs.d/lisp/mb-settings.el")

  ;; Don't ask when evaluating code blocks
  (setq org-confirm-babel-evaluate nil)

  (let* ((dotfiles-path (expand-file-name "~/.dotfiles"))
         (org-files (directory-files dotfiles-path nil "\\.org$")))

    (defun mb/tangle-org-file (org-file)
      (message "\n\033[1;32mUpdating %s\033[0m\n" org-file)
      (org-babel-tangle-file (expand-file-name org-file dotfiles-path)))

    ;; Tangle Systems.org first
    (mb/tangle-org-file "System.org")
  
    (dolist (org-file org-files)
      (unless (member org-file '("README.org" "System.org" "Install.org"))
        (mb/tangle-org-file org-file))))

#+end_src
